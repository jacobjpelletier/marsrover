A. Functional Programming Intro
    1. Why Do I need FP?
        a. First and probably most importantly, having a solid understanding of another programming paradigm will help
            you write better code - even if you never end up using a functional language or framework in your job.
        b. It is on the rise, more languages are choosing at least functional-inspired styles, and understanding where
           these ideas are coming from will help you learn them faster
        c. It will make learning React less mysterious. React and Redux both heavily ascribe to functional principles.
    2. https://www.youtube.com/watch?v=eis11j_iGMs
        a. y combinator: https://www.youtube.com/watch?v=9T8A89jgeTI
        b. Variable values cannot be edited, but.. functions can return new values.
        c. Programs can be expressed completely with... chains of functions and inputs
        d. Functions... have no effct except the values they return
        e. Dr. Church described programs as assembly lines of functions that... are like black boxes, you cannot
            see the logic inside
B. Programming Paradigms
    1. paradigms
        a. imperative
            - The Imperative Paradigm solves problems with an explicit sequence of commands to get from point A to point
            B. If the code or comments read like a recipe or handbook, it's likely to be imperative. Many programming
            languages, especially dynamic ones, including Javascript, PHP, and Python can be used to write imperative
            programs.
        b. functional:
            - The Functional Paradigm solves problems with functions that hold simple pieces of logic and can
            be chained together to accomplish more complex actions.
        c. OOP
            - The Object-Oriented Paradigm solves problems by defining objects that can hold both values (properties)
            and functionality (methods).
         d. https://cs.lmu.edu/~ray/notes/paradigms/
    2. why learn paradigms?
        a. Javascript is a dynamic language, so you can choose which paradigm to use
        b. how do you choose a paradigm?
            - Here are some things to consider. If your application is inherently state-based, like maybe a simple game,
             blog, or a GUI, it is likely a good candidate for Object Oriented programming, because the entities in an
             Object Oriented program are easier to reason about.
            - On the other hand, if you have a large program that needs to have a high degree of reliability, or if you
            need to manage lots of user interactions and fast updates, then it might be a good sign that you could write
            a Functional program. Functional programs shine especially when you need to leverage concurrency. As chips
            have become about as fast as we can make them, the way to get faster computers has been to add more cores.
            But those cores are useless to make our programs faster unless we can use them well. For a program that
            manages concurrency well, you probably would want to rethink your decision to use JavaScript, but the
            Functional Paradigm would be the best choice.
            - It turns out though, that the choice of programming paradigm is quite personal and subjective among
            developers. Many people will learn a paradigm and more or less stick to it. For instance, a person who is
            comfortable with Object Oriented programs will trend towards creating more Object Oriented programs, because
            at the end of the day, we want to build things more than we want to think about building things.
    3. comparing paradigms
        a. imperative

            let name = 'Captain Kirk'
            let hour = new Date().getHours()

            let greeting = ''

            if (hour <= 6) {
                greeting = 'Good Morning, '
            } else if (hour >= 17) {
                greeting = 'Good Evening, '
            } else {
                greeting = 'Hello, '
            }

            greeting += name + '.'

            console.log(greeting)

        b. functional

            const greet = (name) => (salutation) => `${salutation}, ${name}.`

            const determineSalutation = (callback) => {
                const hour = new Date().getHours()

                if (hour <= 6) {
                    return callback('Good Morning')
                } else if (hour >= 17) {
                    return callback('Good Evening')
                } else {
                    return callback('Hello')
                }
            }

            let result = determineSalutation(greet('Captain Kirk'))
            console.log(result)
            //expected output: Hello, Captain Kirk

        c. oop

            class Person {
                constructor(name){
                    this.name = name
                }

                determineSalutation(date){
                    const hour = (date && date.getHours()) || new Date().getHours()

                    if (hour <= 6) {
                        return "Good Morning"
                    } else if (hour >= 17) {
                        return "Good Evening"
                    } else {
                        return "Hello"
                    }
                }

                greet() {
                    return `${this.determineSalutation()}\u00A0${this.name}`
                    // using JavaScript template literal: `${}`
                    // \u00A0 is a symbol to add a space in the template literal
                }
            }

            const kirk = new Person("Kirk", "Captain")
            console.log(kirk.greet())
            //expected output: Hello, Captain Kirk

            class WarpDrive {
                // Creating a class requires us to decide what properties to give it.
                // Take a look at the imperative program - everything that was a global variable there, we want to make a property on our class
                constructor(type, recipient) {
                    this.type = type
                    this.status = 'active'
                    this.warp = 2
                    this.recipient = recipient ? recipient : 'Captain'
                }

                // The bulk of the logic that the imperative program had in the global scope, we turn into methods
                // The logic will stay mostly the same but we now need to reference values that belong to this instance of class WarpDrive, instead of global variables

                status_report() {
                    if (this.status === 'active' && this.warp <= 4) {
                        return this.recipient + ', the engines are active and we could be going faster'
                    } else if (this.status === 'active' && this.warp > 4) {
                        return this.recipient + ', the engines are active and we are going ' + this.warp
                    } else if (this.status === 'down') {
                        return this.recipient + ', the engines are down'
                    } else {
                        return this.recipient + ', the comms are down and we can`t reach engineering'
                    }
                }

                // Anytime you see a variable changing in the imperative program, it is a sign that a method will be needed in this class
                // I added these setter methods as examples for how you could update the state of the object to test the various status_report responses

                set_status(status) {
                    this.status = status
                }

                set_warp(integer) {
                    this.warp = integer
                }
            }

            // Because we are working with classes now, we have to instantiate the class before we use it

            let enterprise_warp = new WarpDrive('Dilithium Chrystal')

            // NOTE: This is a big win for the object oriented style - it is so easy to make multiple instances of WarpDrive
            // Our program could simultaneously reference as many warp drive as instances as we want -- how would you do that in the imperative program?

            enterprise_warp.set_warp(2)

            console.log(enterprise_warp.status_report())

            // expected output: Captain, the engines are active and we could go faster.

    4. Foundations of FP
        a. pure functions
            - Pure functions are a simple concept with big implications. And to start off with, I’m pretty sure you have
                 already written a pure function! If you started off learning to write functions like this:

                function add(x,y) {
                    return x + y
                }

            - https://mostly-adequate.gitbooks.io/mostly-adequate-guide/ch03.html

        b. Summary on pure functions
            - We just learned about side effects, which modify state and don't come from the return statement of that
            function. So now we have everything we need to understand pure functions. Same inputs get the same output
            and the return value is the total effect of running the function.
            - What do we get from writing pure functions? To sum it up in one word, I would say confidence. But there is
            a lot more to it than that. Here are some last points to consider:

                - If we can count on a function to produce the same result no matter where in the program it runs, then we
                don’t have to be afraid of calling it anywhere. It makes my functions easy to reuse.
                If a function has no side effects, then we remove the mental load of needing to remember them. I have
                - confidence about what my functions do, and the effect they will have on my app. That confidence means
                that I can scale things more easily and alter programs with less fear.

            - immutability
                - Another major tenant of functional programming is that we do not “edit” things; we make new things.
                - For instance, if I had a set of notes for a class, and you wanted to borrow them, when you see
                something that you wanted to edit or add, you wouldn’t make those edits on my notes...hopefully.
                Instead, you would make a fresh copy of my notes and make your changes there. That would preserve my
                copy and let you have your new notes; in essence, that is what functional programming wants.
                - Editing - more commonly referred to in development as “mutating” the same thing over and over again
                makes it hard to know what copy you are looking at, and is prone to errors. At multiple points later in
                the course, we will take a look into how we can create immutable values in our JavaScript programs.
                For now though, this will hopefully explain why we favor ‘const’ variables over ‘let’ variables in this
                course.
            - New Terms
                - Pure Functions - A function that will always return the same output if given the same input, and
                which has no side effects.
                - Side effects - An effect on your overall program from running a function, that did not come from the
                return statement of that function.
                - Immutable - Unchanging. Immutable values are ones which, once declared, cannot be changed.
            - summary
                - The content we learned in this section has an amazing ability to improve your everyday coding skills,
                    even if you aren’t writing a Functional program.
                - You learned that pure functions are completely predictable in their outcome, and as a developer,
                    predictable is exactly what you want your programs to be.
                - Avoiding side effects is partly what makes pure functions predictable, and they also make code easier
                     to read, and reduce the interdependence of programs and functions.
                - We also covered a little bit of how immutable values make it easier to track changes over time, and
                    that it is preferable to make a copy of a value before editing it, rather than making changes to
                    the original.
                - We have now covered the core concepts of Functional Programming. There will be a few more throughout
                    the course, but even using and understanding just these have the power to improve the quality and
                    clarity of your programs.
    5. functional pros and cons
        a. Functional Programming believes that values shouldn’t be sloppily edited, but rather replaced with fresh
        values every time. It also ensures that state changes in very predictable places -- the return values of
        functions. You’ll see that a lot of these pros and cons have to do with how state is handled.
        b. pros
            - Easier to test
              Because every function is pure, we know that the return value is the sum of the function, and is the only
              part that needs to be tested. Functions that avoid side effects are easier to test.

            - More predictable code
              Functions that avoid side effects and the use of immutable values makes changes in the programs more
              visible. By definition, pure functions always return the same value when given the same inputs. This
              predictability is the backbone of success with Functional Programming

            - Easier to edit and expand
              Because pure functions return the same value every time, and perfectly encapsulate their logic in the
              return statement, it means that a function could be copied and pasted to a new part of a program, or
              moved to an entirely different program, and it would still always produce the same result. Functions with
              side effects cannot be moved without the possibility of breaking something.
        c. cons
            - More difficult to write in some languages
              While most modern dynamic languages have the ability to write in a Functional style, it can go against
              the grain with some. Even JavaScript, for instance, does not have a way to make values truly immutable.
              Writing programs without classes goes against the grain of Ruby, and PHP does not have all the array
              methods JavaScript has that follow a Functional methodology.

            - Will never be able to implement completely
              There is a big difference between pure academic Functional programming and practical Functional-inspired
              programming for the web. Unless you are using a language that was built to be Functional, like Haskell,
              there will be times you have to work within the limits of the language to do the best you can at writing
              functional programs.

            - Few libraries to speed progress (though this is changing)
              Functional programming for the web is still fairly new, and there are not as many helpful libraries or
              tutorials for getting started or writing efficiency as there are for say Object Oriented programs, for
              which we have prebuilt ORMs, tons of tutorials, frameworks, etc..
C. Function JS syntax
    1. arrays
        a. map method:

            const captains = ['Picard', 'Adama', 'Reynolds', 'Beeblebrox']

            // create new array
            const titles = captains.map(cap => `Captain ${cap}`)

            // equivalent to
            const titles = captains.map(cap => {
                return `Captain ${cap}`
            })

            console.log('Resulting Array: ', titles)
            // expected output: Resulting Array: ['Captain Picard', 'Captain Adama', 'Captain Reynolds', 'Captain Beeblebrox']
            console.log('Original Array:', captains)
            // is unchanged, expected output: Original Array: ['Picard', 'Adama', 'Reynolds', 'Beeblebrox']


            const nums = [1, 2, 3, 4, 5]

            // Internal callback
            // ----------------------------------------------------------------------
            const doubles = nums.map(x => x * 2)

            console.log(doubles)
            // expected output: Array [2, 4, 6, 8, 10]

            // External callback
            // ----------------------------------------------------------------------
            const doubler = function(x) {
                return x * 2
            }

            const doubles2 = nums.map(x => {
                return doubler
            })

            console.log(doubles2)
            // expected output: Array [2, 4, 6, 8, 10]

            // 1. Write a map function to reverse this array:
            const start = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

            const end = start.map(x => Math.abs(x - 11))
            console.log(end)
            // expected output: Array [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]

            // ----------------------------------------------------------
            // 2. Write a map function to print the Job: Name:
            const shipMates = [["Mal", "Captain"], ["Wash", "Pilot"], ["Zoey", "1st Mate"], ["Jayne", "Public Relations"]]

            const result1 = shipMates.map(arr => arr.reverse().join(': '))
            console.log(result1)

            // expected output: Array ["Captain: Mal", etc...]

            // ----------------------------------------------------------
            // 3. Write a map function that prints the name: even|odd
            const awayTeam = ["Picard", "Riker", "Troy", "Data"]

            const result2 = awayTeam.map((name, i) => `${name}: ${i % 2 === 0 ? 'even' : 'odd'}`)
            console.log(result2)
            // expected output: Array: ["Picard: even", "Riker: odd", etc...]


            // ----------------------------------------------------------
            // 3. Create a multidimensional array of each item and its index in the original Array

            const sciFiShows = ['Manedlorian', 'Enterprise', 'Firefly', 'Battlestar Galactica']

            const result3 = sciFiShows.map((show, index) => [show, index])
            console.log(result3)
            // expected output: Array [['Manedlorian', 0], ['Enterprise', 1], ['Firefly', 2], ['Battlestar Galactica', 3]]

            // ----------------------------------------------------------
            // 4. For each item in this array, create a multidimensional array containing the entire original array

            const numbers = [1, 2, 3, 4]

            const result4 = numbers.map((num, index, wholeArray) => wholeArray)
            console.log(result4)
            // expected output: Array [[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]]


            // ----------------------------------------------------------
            // 5. One common thing we use `map` for in real life is to reformat objects to have a shape that is better for our
            // purposes. For instance, we only care about the name and first three characters of the id for the races below.
            // Use `map` to grab those values and create a new array with them.

            var index = [
                {key: 1, sector: 10, t_score: 18, id: '1236n7e8', value: 'Klingon'},
                {key: 4, sector: 145, t_score: 12, id: '293847hs8', value: 'Minbari'},
                {key: 8, sector: 214, t_score: 5, id: '283hy8347', value: 'Cylon'},
                {key: 3, sector: 8346, t_score: 10, id: 'n9837ks857', value: 'Jawa'},
            ]

            const result5 = index.map((race) => {
                return { name: race.value, idFirstThree: race.id.substring(0,3)}
            })

            console.log(result5);

        b. filter method
            - The filter method is a separator, we give it a function with the logic to distinguish the items we want,
            and filter runs items in the array through that function. In the end, it creates a new array that contains
            only the elements that our function allowed. So the ONLY difference between filter and map is that map
            performs a function on every item in an array, and filter uses a true or false conditional on every item in
            the array to decide if that value should be kept or discarded. This means that one key differentiator of the
            filter method is its callback method must return either true or false. If it returns true, the value will be
            added to the result array; if it returns false, that value is discarded.
            - Filter is easiest to learn when you play around with it. Below, you can see how a filter is applied to the
            values list. This function is looking to see if each value in the array resolves to ‘true’ or not. So the
            ‘filter’ function we are running looks like this: (v == true), where ‘v’ is each value in turn. Only array
            items where this condition is ‘true’ will be included in the new array ‘result’.

                const values = ['true', true, 'yes', 'no', 1, 0, 'false', false];

                const result = values.filter(v => v == true);

                console.log(result);
                // expected output: Array [true, 1]


        c. reduce method
            - The map and filter methods have a lot in common, they both:
                - Run a function (callback given by the developer) on every item in an array.
                - Pass three arguments to the function (item value, item index, whole array).
                - Return a new array.
            - The reduce method has some slight differences. From the name you might be able to guess that this method
            boils our array down to a single value.
            - For example, if you have an array of products, each with a price, you could use reduce to sum the price
            values of each item and return a single total cost. Reduce has the special ability to keep track of a value
            that is updated as it iterates over each item in the array. To get the total cost from an array of items
            with a price value, you would write a function that adds an item's price to the running total and reduce
            will run that function on each item in the array until it runs out of items and the total is found.
            - To do this, reduce only passes the callback two arguments, the total so far - or accumulator, and the
            current item. Another way that it differs from the first two array methods is that it does not necessarily
            return an array. In the case of the example above, reduce would return a single integer of the sum of all
            prices.
            - Below, you can see how reduce is applied to the sales list. Reduce goes through the list sales and adds
            the individual value to a running total which is what will ultimately be returned by reduce. The final
            output of reduce on sales will be 147.49.

                const sales = [120.00, 19.99, 3.50, 4.00];

                const total = sales.reduce((runningTotal, currentValue) => {
                    console.log(runningTotal, currentValue)
                    return runningTotal + currentValue
                })

                // cycle 1: 120 19.99
                // cycle 2: 139.99 3.5
                // cycle 3: 143.49 4

                // expected output: 147.49

                // If you can follow the code above - great job! No one masters the reduce method overnight, but being able to follow the code is the first step. Below are two examples of alternate syntax that you might also see out in the wild. Can you follow these?

                //  SAME AS:
                const reducer = (runningTotal, currentValue) => runningTotal + currentValue;
                console.log(sales.reduce(reducer));

                // Look! You can even run map, filter, and reduce on array literals!
                // SAME AS:
                [120.00, 19.99, 3.50, 4.00].reduce((runningTotal, currentValue) => {
                    return runningTotal + currentValue
                })

        d. summary

        Map - The map method iterates over every item in the array it is called on, and performs one action on each
        item. The action logic is held in a callback function. The map method returns a new array that is the same
        length as the original array, but with the items updated according to the callback function logic.

        Filter - The filter method iterates over every item in the array it is called on, and runs each item through a
        pass or fail checking logic. The logic is held in a callback function which must return either true or false.
        The filter method returns a new array that is shorter than the original array (or potentially the same length,
        if all values passed successfully through the callback), but the values that pass through will be unchanged.

        Reduce - The reduce method iterates over every item in the array it is called on, and keeps one value (for
        instance, the sum of all prices). Each item in the array is forgotten, and the end result is a single value.
        The uses of reduce vary greatly depending on your need, and it is typically the hardest one of the three array
        methods to master because though its logic is not complicated, its use cases can be very creative.

        That concludes our whirlwind tour of the most commonly used array methods! Practicing these will help you in
        your day to day work, and making them second nature will really help in interviews and coding challenges.

    2. Array methods for selection
        a. flat
            - Sometimes we have to deal with arrays within arrays - also called multidimensional arrays. The bigger and
             more nested multidimensional arrays get, the harder they become to wrap your head around, and accessing
             information can be a headache. flat is a tool that allows you to undo array nesting to exactly the level
             you want.
            - In the following code, flat is applied to arrays: nestedArr and moreNested. The first instance with
            nestedArr, flat takes away the higher level of nesting. But with moreNested we can see when flat takes in
            an integer parameter, it will flatten 2 levels of nesting. This returns an array without any nesting.

                var nestedArr = [1, 2, [3, 4, [5, 6]]];
                nestedArr.flat();
                console.log(nestedArr)
                // expected output: [1, 2, 3, 4, [5, 6]]

                var moreNested = [1, 2, [3, 4, [5, 6]]];
                moreNested.flat(2);
                console.log(moreNested)
                // expected output: [1, 2, 3, 4, 5, 6]

        b. find
            - Locating unique values in arrays is another indispensable ability. JavaScript find and Includes methods
            perform similar actions, but their use cases differ. Here are their Mozilla definitions side by side:
                - Find Method
                    - find returns the value of the first element in the provided array that satisfies the provided
                    testing function.
                - Includes Method
                    - includes determines whether an array contains a certain value among its entries, returning true or
                     false as appropriate.
            - find is most useful when you are not looking for a specific value. It is best to use find when you want
            to see if any item in array meets a criteria. In this way, find is a little bit like filter, in that they
            both run every item in array through a function to determine if the item passes the function’s requirement.
            But, find is a little bit simpler in that it only passes a single argument (the current value) and returns
            a single value from the array (the first one to pass the function’s test).

                const bestBars = [
                    'Mos Eisley Cantina',
                    'Clark`s Bar',
                    '10 Forward',
                    'The Restaurant at the End of the Universe',
                    'The Prancing Pony',
                    '10 Forward',
                ]

                const test1 = bestBars.find(x => x === 'Quark`s Bar')
                const test2 = bestBars.find(x => x === '10 Forward')

                console.log(test1) //expected output: undefined
                console.log(test2) // expected output: 10 Forward
        c. include
            - includes is most useful when are looking for the existence of a specific value. All you have to do is
            provide the value you are looking for, and includes will return true if it finds it and false if it does not.
            - It is good to note that neither find nor includes is a good tool to use if you need to know how many
            times a value is found in an array. To do that, you would have to use map or filter.
            - In the following code, you can see that includes only returns a true or false value. Includes can also be
            used on strings.

                const bestBars = [
                    'Mos Eisley Cantina',
                    'Clark`s Bar',
                    '10 Forward',
                    'The Restaurant at the End of the Universe',
                    'The Prancing Pony',
                    '10 Forward',
                ]

                const test1 = bestBars.includes('Quark`s Bar')
                const test2 = bestBars.includes('The Prancing Pony')

                console.log(test1) // expected output: false
                console.log(test2) // expected output: true

    3.  variables
        a. let
            - let is like var in that a value can be edited after it has been declared, but the scoping rules are a bit
            different between the two.
        b. const
            - const is what we are going to focus on in this course, and right now, we are just going to look at how
            const does not go far enough to really be considered functional. In the following example, take a close
            look at how the consts ‘currentBook’ and ‘bookDetails’ behave differently. We can’t edit ‘currentBook’ -
            as expected - but we CAN edit ‘bookDetails’. Feel free to run and edit the code below to get a feel for
            what you can and can’t do.

                const currentBook = 'The Time Machine'

                const bookDetails = {
                   title: 'The Time Machine',
                   author: 'H. G. Wells',
                   totalPages: 84,
                   currentPage: 42
                }

                const library = ['Dune', 'Nineteen Eighty-Four', 'Ender`s Game', 'Hyperion', 'Fahrenheit 451']

                currentBook = 'Stranger in a Strange Land'
                // results in error, can't edit const value

                bookDetails = {
                   title: 'I, Robot',
                   author: 'Isaac Asimov',
                   totalPages: 253,
                   currentPage: 21
                }
                // results in error, bookDetails is read-only

                bookDetails.currentPage = 75
                // this works! We can update values within a const object

                library = ['Dune', 'Nineteen Eighty-Four']
                // results in error, can't redeclare library

                library.concat('The Hitchiker`s Guide to the Galaxy')
                // this works! We can update items in the array or add to it
                // Note that concat is the best non-mutative way to add items to an array

            https://hackernoon.com/why-you-shouldnt-use-var-anymore-f109a58b9b70
            https://dev.to/johnwolfe820/should-you-never-truly-use-var-bdi

        c. object freeze

            // ----------------------------------------------------------
            // OBJECT FREEZE EXAMPLES
            // ----------------------------------------------------------

            const currentShow = {
                title: 'Dr. Who',
                seasons: 11,
                currentSeason: 4
            }

            // as a const, we can do this:
            currentShow.currentSeason = 5
            // expected output: { title: 'Dr. Who', seasons: 11, currentSeasons: 5 }

            // but if we freeze the object
            Object.freeze(currentShow);

            currentShow.currentSeason = 6;
            // this would actually cause an error

            console.log(currentShow)
            // expected output: {title: 'Dr. Who', seasons: 11, currentSeasons: 5 }
            // now that it is frozen we can not update the current season of the current show

        - freeze
            - A frozen object can no longer be changed.” A frozen object can have no properties added to it, removed
             from it, or its values edited. It effectively makes an immutable object.
    4. keys()
        - This method returns an array of strings of all an object’s property names. This is unusual because most
          methods we run on objects are more interested in the values.
        - Be aware though, this won’t always get the results you think. Along with the properties you are aware of in
          an object, this might also return other properties belonging to the prototype.
    5. assign()

        let state = {
            name: 'Wash',
            ship: {
                name: 'Serenity',
                class: 'Firefly'
            }
            role: 'Pilot',
            favoriteThing: {
                item: "Toy",
                details: {
                        type: 'Toy Tyrannosaurus Rex'
                }
            }
        }

        const newState = {
            name: 'Mal',
            role: 'Captain',
            favoriteThing: {
                item: "Not complicated"
            },
            history: ["Browncoat sergeant"]
        }

        state = Object.assign(state, newState);
        // Object.assign(state, newState)

        console.log(state)
        // expected output:
        // { name: 'Mal',  ship: { name: 'Serenity', class: 'Firefly' },
        //  role: 'Captain',
        //  favoriteThing: { item: 'Not complicated' },
        //  history: [ 'Browncoat sergeant' ] }

    6. method examples

        // ----------------------------------------------------------
        // OBJECT FREEZE EXERCISE
        // Create your own object and freeze it!
        // Below is an example of a solution to the exercise.
        // --------------------------------------------------------

        // much like the example you saw in the video create an object

        const person = {
            name: 'Synthia',
            age: 12
        }
        console.log(person)
        // expected output: {name: 'Synthia', age: 12}

        person.age = 13
        console.log(person)
        // expected output: {name: 'Synthia', age: 13}

        Object.freeze(person)

        person.age = 14
        console.log(person)
        // expected output: {name: 'Synthia', age: 13}

        // ----------------------------------------------------------
        // OBJECT KEYS EXERCISES
        // Use Object.keys with the map method to print "This character has a(n) [property-name]" for each property.
        // ----------------------------------------------------------
        // GIVEN
        const character = {
            id: '12mn18udcbv9823',
            name: 'Chewbacca',
            race: 'Wookie',
            planet: 'Kashyyyk',
            job: 'First Mate'
        }

        // SOLUTION CODE
        const keys = Object.keys(character)

        keys.map(key => {
            console.log(This character has a(n) ${key})
            return This character has a(n) ${key}
        })

        // Expected Output:
        // This character has a(n) id.
        // This character has a(n) name.
        // This character has a(n) race.
        // This character has a(n) planet.
        // This character has a(n) job.
        // [ 'This character has a(n) id',  'This character has a(n) name',  'This character has a(n) race', 'This character has a(n) planet', 'This character has a(n) job' ]

        // ----------------------------------------------------------
        // OBJECT ASSIGN EXERCISES
        // Merge another character into this state. Keep at least one value and change at least one value. Below is an example of a solution to the exercise.
        // ----------------------------------------------------------

        let state = {
            name: 'Wash',
            ship: {
                name: 'Serenity',
                class: 'Firefly'
            },
            role: 'Pilot',
            favoriteThing: {
                item: "Toy",
                details: {
                    type: 'Toy Tyrannosaurus Rex'
                }
            }
        }

        const incomingState = {
            name: 'Mal',
            role: 'Captain',
            favoriteThing: {
                item: "Not complicated"
            },
            history: ["Browncoat sergeant"]
        }

        state = Object.assign(state, incomingState);
        // expected output:
        // state = {
        //     name: "Mal",
        //     ship: {
        //         name: "Serenity",
        //         class: "Firefly"
        //     },
        //     role: "Captain",
        //     favoriteThing: {
        //         item: "Not complicated"
        //     },
        //     history: ["Browncoat sergeant"]
        // }

D. Functional Programming in JS
    1. intro to FP in JS
        a. Higher-Order Functions are not only used in Functional programming but are a central part of Functional
        programs specifically. Higher-Order Functions (HOFs) allow us to string together many functions. HOFs have
        slightly different definitions across programming languages, but in JavaScript, you can say that a function is
        Higher-Order if it:
            - Takes in a function as an argument (a callback)
            - Returns a function
        b. We are already quite familiar with functions that take a callback. Map, Filter, and Reduce are all HOFs.
        When a function returns another function, it forms a closure around that function, typically to wrap it with
        extra functionality. HOFs are an important tool for creating more-complex Functional programs in JavaScript.

            // Doubling
            const nums = [1, 2, 3, 4, 5]
            const doubles = nums.map(x => x * 2)

            console.log(doubles)
            // expected output: Array [2, 4, 6, 8, 10]

            // Equivalent to:
            const doubler = function (x) {
                return x * 2
            }

            const doubles2 = nums.map(doubler)

            // inside map…
            // doubler(1, 0, [1, 2, 3, 4, 5])

            console.log(doubles2)
            // expected output: Array [2, 4, 6, 8, 10]

    2. functional data manipulation
        a. tips
            - determine data points and shape you need
            - locate one individual item and use it as an example
            - working up the data tree might be easier than working down the tree
            - extract the info you need as soon as you can
    3. functional DOM manipulations
        a. functional style

            const root = document.getElementById('root')
            // First Pass - Basic Layout
            const render = root => {
                root.innerHTML = `<div> I EXIST! </div>`
            }

            render(root)

            // Second Pass - Easier to add more layout
            const render = root => {
                root.innerHTML = App()
            }

            const Welcome = () => {  // pure function

                return `Welcome to my JavaScript Program!`
            }

            const App = () => { // higher-order and pure function
                return `
                    <h1>${Welcome()}<h1>
                   <div> I EXIST! </div>
                `
            }
            render(root)

        b. state
            - We have seen that we can create elements in our JavaScript program and make them appear in the DOM, but
            now how do we hold onto values, take in data and do all the other things necessary for an interactive app?
            That is the focus of this section. We need a place to hold information. Our app is likely going to collect
            information from users or receive it from an API, and we need an organized way to handle data from any
            source. Functional Programming stays away from creating a global state, but in a real life web application,
             sticking to that rule proves difficult and overly complicated to do. Instead of no global state, what we
             can do is create just one place for all that global information to live. We will create an immutable object
             to store data - Functional Programming has no rules against that - and we will use this immutable object as
             the single source of truth for our application’s data.

                const store = {
                    user: {
                        first_name: ‘John’,
                        last_name: ‘Doe’
                    }
                }

            - Store is a generic term for an object that stores application data. That will be the purpose of this
            immutable object, so we named it store and it can now be passed as an argument into our functions.

                const render = (root, state) => {
                   root.innerHTML = App(state)
                }

                const Welcome = (name) => {
                   return `Welcome, ${name} to my JavaScript Program!`
                }

                const App = (state) => {
                   return `
                       <h1>${Welcome(state.user.first_name)}<h1>
                      <div> I EXIST! </div>
                   `
                }

                render(root, store)

            - Here we have taken the code that generated the DOM elements in the last section and passed our new store
            object to it so that data is accessible to our component functions. One more thing, if you have recreated
            these two sections on your own computer and tried to see the results in your browser, there was likely a
            problem and nothing showed up on the screen except what was in your index.html file. Why’s that? Because we
            are missing one function that tells the JavaScript when to run. You might have seen this function from other
            Javascript programs for the browser. We need to wait for the load event to make sure that our JavaScript
            doesn’t run before the DOM element ‘root’ exists.

                window.addEventListener('load', () => {
                   render(root, store)
                })

        c. example

            // Here is the code from the example text

            const root = document.getElementById('root')

            const Welcome = () => {
                return `Welcome to my JavaScript Program!`
            }

            const App = () => {
                return `
                    <h1>${Welcome()}<h1>
                    <div> I EXIST! </div>
                `
            }

            const render = root => {
                root.innerHTML = App()
            }

            render(root)

            // Add a new Menu component that takes in a show argument which is either true or false
            // Show this content if show is true:
            {/* <nav>
                <ul>
                    <li>About Us</li>
                    <li>Contact Us</li>
                    <li>Login</li>
                </ul>
            </nav> */}

            // and this content if show is false:
            {/* <nav>Menu</nav> */ }

            const Menu = (show) => {
                if(show) {
                    return (`
                            <nav>
                                <ul>
                                    <li>About Us</li>
                                    <li>Contact Us</li>
                                    <li>Login</li>
                                </ul>
                            </nav>
                        `)
               }
                return `<nav>Menu</nav>`
            }


            // Given

            let store = {
                user: {
                    first_name: 'John',
                    last_name: 'Doe'
                }
            }

            const render = (root, state) => {
                root.innerHTML = App(state)
            }

            const Welcome = (name) => {
                return `Welcome, ${name} to my JavaScript Program!`
            }

            const App = (state) => {
                return `
                   <h1>${Welcome(state.user.first_name)}<h1>
                  <div> I EXIST! </div>
               `
            }

            window.addEventListener('load', () => {
                render(root, store)
            })
            // But what if state changes at some point in our app?
            // Using the object methods we have learned so far in this course,
            // create a function called updateStore that takes in the old state, the new state, and updates the old state with any new information
            // This won't be a pure function, instead of a return, call the render method again

            const updateStore = (store, newState) => {
                store = Object.assign(store, newState)
                render(root, store)
            }

        https://eloquentjavascript.net/05_higher_order.html

E. Going further with functional JS
    1. intro
        a. We’re in the home stretch! We’ve finished our investigation of the Javascript tools we have to write
        Functional programs, and we’ve seen first hand how those tools can be used to create an interactive program
        without the use of any external libraries. Now it's time to get a wider view of all that’s possible with
        Functional Programming and some of the awesome libraries built on top of these powerful concepts.
        b. In this lesson, we will do a very high-level overview of a few of the most common Functional libraries for
        JavaScript - ImmutableJS, Ramda, RxJS, and Redux. The point of this lesson is not to teach you all there is to
        know about these awesome tools, but only to show three real life uses of the Functional concepts we have learned.
        Here and there I will stop to explain a new concept or look at some code, but the sole focus of this section
        will be to highlight how these tools put different Functional practices to good use. None of the lessons in
        this section should be seen as a tutorial on how to set up or use these libraries in an application. To go into
        more detail for any of these technologies would require another course of its own, so instead I will provide
        resources for where you can continue learning about each library on your own.

    2. persistent data structures
        a. immutable DS
            - Before we jump into our first library, ImmutableJS, we need to talk about once concept - Immutable Data
            Structures. When I first introduced the concept of immutability, I intentionally did not touch on one very
            important part of immutability -- space. If variables cannot change the values they hold, how do your
            programs not need huge amounts of memory to hold all those copies of old data? If even the smallest change
            to a value occurs, the Functional Paradigm would say that we need to create a unique variable - even if 99%
            of it is identical to the previous. This could not possibly be an efficient use of memory, especially for
            large programs, so how is this handled? Instead of making copies of variables, we make trees of data and
            have the variables reference values in the tree. That is a lot of new words and is probably confusing, so
            we will walk through an example in the next video.
            - https://www.youtube.com/watch?v=Wo0qiGPSV-s
            - In Javascript, we are going to build a naive example of an array type persistent data structure.
            - First, we will create a class - we’ll call it PersistentArray. We are creating a class because it is the
            easiest way to wrap an array with extra functionality. Again, this wouldn’t really be something you would
            use in a real application, it is only an example to highlight some of the features of a persistent data
            structure. So here is our new kind of persistent array:

                class PersistentArray {
                        constructor(items = []) {
                                this.persistentArray = items
                        }
                }

                const a = new PersistentArray([1, 2, 3])
                console.log("A", a)

            - You can see that PersistentArray takes in an array of items or defaults to an empty array if no arguments
            are provided. Then our class has a property of persistentArray, this will be a normal javascript array.
            - Now imagine that we want to add a new item to this array. But we can’t just push a new value onto the
            array, because we can’t edit the original. So our PersistentArray class isn’t going to let us edit the
            original, it is going to five us a new array with the change made on that array by default. We are going
            to implement our own “push” method to work on our PersistentArray.

                class PersistentArray {
                        constructor(items = []) {
                                this.persistentArray = items
                        }

                        push(newItem) {
                             return new PersistentArray(this.persistentArray.concat(newItem))
                         }
                }

                const a = new PersistentArray([1, 2, 3])
                console.log("A", a)

                const b = a.push(4)
                console.log("A", a)
                console.log("B", b)

                /* output
                    A PersistentArray { persistentArray: [ 1, 2, 3 ] }
                    A PersistentArray { persistentArray: [ 1, 2, 3 ] }
                    B PersistentArray { persistentArray: [ 1, 2, 3, 4 ] }
                */

            - You can see now that we are creating a push method which takes in one new value and returns a whole new
            class instance with an array that contains the new item. And you can see when we console log the results
            that array A is unchanged and the new array B contains the array with ‘4’ added to it. So in persistent
            data structures, you can see that once a value is created it can never be changed.
            - Where our example differs from a truly persistent data structure - and why this is such a naive example -
            is the memory sharing. When our custom push method creates the new class instance, it takes up an entirely
            new spot in memory, it is saved as its own entity. But in a true implementation of this, array A and array
            B would share memory, only differing by one node (the new ‘4’ value we added to B).
            - So now let’s explore the other side and implement a pop method. Take a look at this code.

                class PersistentArray {
                    constructor(items = []) {
                                this.persistentArray = items
                    }

                    push(newItem) {
                                return new PersistentArray(this.persistentArray.concat(newItem))
                    }

                    pop() {
                                let poppedArray = [...this.persistentArray]
                                poppedArray.pop()
                                return new PersistentArray(poppedArray)
                    }
                }

                const a = new PersistentArray([1, 2, 3])
                console.log("A", a)

                const b = a.push(4)
                console.log("A", a)
                console.log("B", b)

                const c = a.pop()
                console.log("A", a)
                console.log("B", b)
                console.log("C", c)

        3. immutableJS
            a. First, because Immutable is an external library, we have to add it to our project. We can do that one of
            two ways: via a script tag in an HTML page, or via a node module. Choose whichever one is more convenient
            for your application. For this course, we are going to use the browser script tag implementation. Here is
            an example of how ImmutableJS is implemented.

                // Put this in an html page
                <script src="https://cdnjs.cloudflare.com/ajax/libs/immutable/3.8.2/immutable.min.js"></script>

                // Or, you can install `immutable` module using npm and import this module in a js file
                npm install immutable // install immutable from the terminal
                const Immutable = require('immutable'); // add this line in js file

            b. syntax

                // Getting and Setting values using Immutable module

                // Immutable objects are called ‘maps’
                const Immutable = require('immutable'); // import immutable module

                // this is how we declare an immutable Object
                const map1 = Immutable.Map({ a: 1, b: 2, c: 3 });


                // Here is an important part. We can’t update map1, so instead we have to make the change on map2.
                const map2 = map1.set('b', 50);

                // Because of this, the old state of map1 is still available
                map1.get('b'); // 2

                // And map2 shows our update.
                map2.get('b'); // 50
                console.log(map2.get('b'))

                // equality check
                map1.equals(map2); // false
                console.log(map1.equals(map2))

                // Use with ordinary objects
                const state1 = Immutable.Map({ a: 1, b: 2, c: 3, d: 4 });
                const state2 = Immutable.Map({ c: 10, a: 20, t: 30 });
                const obj = { d: 100, o: 200, g: 300 };
                const map3 = state1.merge(state2, obj);
                console.log(map3.toJS()) // toJS() is a helper method to convert immutable object into javascript dictionary

                // If you open the returned object, you can see that it isn't an ordinary object
                // you'll find all the properties under "entries"

                // Use with ordinary arrays
                // An immutable array is declared as a `List` like this:
                const numbers = Immutable.List([1, 2, 3]);

                //But Immutable can also work with plain JS arrays
                const otherNumbers = [4, 5, 6]


            c. ex

                PART 1. Getting and Setting values
                // Given the following object, make an update that turns name to 'Mal' and role to 'Captain'

                const state1 = Immutable.Map(const map1 = Immutable.Map({
                    name: 'Wash',
                    ship: {
                        name: 'Serenity',
                        class: 'Firefly'
                    },
                    role: 'Pilot',
                    favorite_thing: {
                        item: "Toy",
                        details: {
                            type: 'Toy Tyrannosaurus Rex'
                        }
                    }
                });

                // SOLUTION
                // You can do this:
                const state2 = state1.set('name', 'Mal')
                const state3 = state2.set('role', 'Captain')

                // But Immutable also allows you to do this:
                const state2 = state1.set('name', 'Mal').set('role', 'Captain')

                // -----------------------------------------------------------------
                // -----------------------------------------------------------------

                // PART 2. More with objects
                // This is a normal javascript object. It is very different from an Immutable Map
                const obj = { d: 100, o: 200, g: 300 };

                // But thankfully, normal javascript objects are still valid in Immutable
                // Notice that here we can merge a normal object into an Immutable Map
                const map3 = state1.merge(state2, obj);

                // But also notice how different the two are when we console log map3
                console.log(map3)

                // YOUR TURN --------------------------------------------------------------
                // Can you locate the contents of our variable 'obj' inside the Immutable Map map3?
                console.log(map3)

                // SOLUTION --------------------------------------------------------------
                // If you open the Immutable map3 in inspect element, you can see that it isn't an ordinary object
                // you'll find all the properties under "entries"

                // -----------------------------------------------------------------
                // -----------------------------------------------------------------

                // PART 3. Arrays and Immutable Lists

                // An immutable array is called a LIST, and is declared like this:
                const numbers = List([1, 2, 3]);

                // We can turn normal JS arrays into Immutable Lists like this:
                const plainArray = [ 1, 2, 3, 4 ]
                const listFromPlainArray = List(plainArray)
                console.log(listFromPlainArray)

                // we can declare a new Immutable List
                const myList = List([ 'stuffed t-rex' ]);
                console.log(Array.from(myList));

                // and we can use the set method again to add or update values. Just provide the index first and value second
                const myList1 = myList.set(1, 'toy lightsaber');
                console.log(Array.from(myList1)); // [ "stuffed t-rex", "toy lightsaber" ]

                // but, in order to not need to supply the index, we can also add new values with push
                const myList2 = myList1.push('Picard bobblehead')
                console.log(Array.from(myList2));

                // YOUR TURN --------------------------------------------------------------------------

                // 1. Turn the following array into an Immutable array
                // 2. Add a character

                // -----------------------------------------------------------------
                // -----------------------------------------------------------------


                // STRETCH CHALLENGE ----------------------------------------------------------------------
                // 3. Remove Jabba the Hut from the Immutable List
                // look up in the documentation how you would remove a character from the Immutable list

                const characters = [
                  {
                    name: 'Marvin the Paranoid Android',
                    role: 'First Mate',
                    universe: 'Hitchhikers Guide to the Galaxy',
                    weapon: 'severe depression',
                    powerLevel: 1000
                  },
                  {
                    name: 'Jabba the Hutt',
                    role: 'villain',
                    universe: 'Star Wars',
                    weapon: 'henchmen',
                    powerLevel:  200
                  },
                  {
                    name: 'Zoë Alleyne Washburne',
                    role: 'First Mate',
                    universe: 'Firefly',
                    weapon: 'Winchester Model 1892 rifle',
                    powerLevel: 160
                  },
                  {
                    name: 'Peter Venkman',
                    role: 'Ghostbuster',
                    universe: 'Ghostbusters',
                    weapon: 'proton pack',
                    powerLevel: 120
                  },
                  {
                    name: 'Kathryn Janeway',
                    role: 'Captain',
                    universe: 'Star Trek',
                    weapon: 'Wit',
                    power_level: 140
                  }
                ]

                // SOLUTION

                const immutableCharacters = List(characters).push({
                    name: 'Yoda',
                    role: 'Jedi Master',
                    universe: 'Star Wars',
                    weapon: 'The Force',
                    powerLevel: 900
                })
                console.log(Array.from(immutableCharacters))

                // STRETCH SOLUTION
                const withoutJabba = immutableCharacters.delete(1)
                console.log(Array.from(withoutJabba))

                // or, all in one line, you could do:
                const allatonce = List(characters).push({
                    name: 'Yoda',
                    role: 'Jedi Master',
                    universe: 'Star Wars',
                    weapon: 'The Force',
                    powerLevel: 900
                }).delete(1)
                console.log(Array.from(allatonce))

        4. rxjs
            a. // Browsers won't run RxJS code on their own, but thankfully RxJS created a tool called the RxJS playground!
               // Take the code below and paste it into https://rxjs-playground.github.io/#/ to see it run


               // A function runs once and returns one set of information
               // An observable is like a function that runs for a period of time and can return many sets of information - a stream of information

               const observable = new Rx.Observable(subscriber => {
                 subscriber.next(1);
                 subscriber.next(2); // "return" another value
                 subscriber.next(3); // "return" another value
                 setTimeout(() => {
                   subscriber.next(4);
                   subscriber.complete();
                 }, 1000);
               });

               console.log('just before subscribe');

               observable.subscribe({
                 next(x) { console.log('got value ' + x); },
                 error(err) { console.error('something wrong occurred: ' + err); },
                 complete() { console.log('done'); }
               });

               console.log('just after subscribe');

               // the word 'next' is a special RxJS observable word that allows the observable to "return" multiple things over a period of time


               // There are three types of values an Observable Execution can deliver:

               // "Next" notification: sends a value such as a Number, a String, an Object, etc.
               // "Error" notification: sends a JavaScript Error or exception.
               // "Complete" notification: does not send a value.

               // "Next" notifications are the most important and most common type: they represent actual data being delivered to a subscriber.
               // "Error" and "Complete" notifications may happen only once during the Observable Execution, and there can only be either one of them.

        5. implementing immutableJS
            a. WATCH OUT! One important thing to note is that nested objects have to be declared as Immutable maps just
            like top level ones. Otherwise, they will be stored as normal JS objects, which Immutable handles
            differently. You can see the difference below.

                // Nest 1
                const currentShow = Immutable.Map({
                    title: 'Dr. Who',
                    seasons: 11,
                    currentSeason: 4,
                    characters: {
                        main: 'The Doctor',
                        supporting: ['Dalek1']
                    }
                })

                // Nest 2
                const currentShow = Immutable.Map({
                    title: 'Dr. Who',
                    seasons: 11,
                    currentSeason: 4,
                    characters: Immutable.Map({
                        main: 'The Doctor',
                        supporting: List(['Dalek1'])
                    })
                })

            - Nest 1 is not the same as Nest 2. The main difference is that the nested object characters is declared
            with Immutable.Map in Nest 2. characters in Nest 1 will not be immutable while characters in Nest 2 will be.

        6. ex

            let store = Immutable.Map({
                user: Immutable.Map({
                    firstName: 'John',
                    lastName: 'Doe'
                }),
            })

            function updateStore(state, newState) {
                store = state.merge(newState)
                render(root, store)
            }

            updateStore(store, newState)
            console.log(store.getIn(['user', 'name']))

    7. rxjs observer

        // A function runs once and returns one set of information
        // An observable is like a function that runs for a period of time and can return many sets of information - a stream of information

        // An observable returns a stream of information
        // An observer (here, observable.subscribe) is how we ‘listen’ or subscribe to data being returned by an observable.

        const observable = new Rx.Observable(subscriber => {
          subscriber.next(1);
          subscriber.next(2); // "return" another value
          subscriber.next(3); // "return" another value
          setTimeout(() => {
            subscriber.next(4);
            subscriber.complete();
          }, 1000);
        });

        console.log('just before subscribe');

        observable.subscribe({
          next(x) { console.log('got value ' + x); },
          error(err) { console.error('something wrong occurred: ' + err); },
          complete() { console.log('done'); }
        });

        console.log('just after subscribe');

        // the word 'next' is a special RxJS observable word that allows the observable to "return" multiple things over a period of time


        // There are three types of values an Observable Execution can deliver:

        // "Next" notification: sends a value such as a Number, a String, an Object, etc.
        // "Error" notification: sends a JavaScript Error or exception.
        // "Complete" notification: does not send a value.

        // "Next" notifications are the most important and most common type: they represent actual data being delivered to a subscriber.
        // "Error" and "Complete" notifications may happen only once during the Observable Execution, and there can only be either one of them.

    8. rambda
        a. Ramda is a library of functions that help JavaScript developers write better Functional code. Where RxJS is
        a whole new way to think about and interact with data streams and events, Ramda’s goal is to do an excellent
        job of providing JavaScript developers with truly Functional tools, and a lot of developers think they have
        done a really good job at that.
        - Some cool things about Ramda:
            - Each function is self-contained, pure, side effect free, and does not mutate anything
            - Each function is written in JavaScript, so with the amount of JavaScript you know now, you can go to the
            source code and be able to understand how they built their function

    9. functional redux
        a.  The actions of the reducer can be compared to a teller at a bank. As a bank patron (event) you want the
        teller to do something to your account such as withdraw, deposit, or create an account (actions) and the teller
        (reducer) is able to make changes to the vault (store) where your money (data) is stored.
        b. Redux is a library typically imported into larger applications to manage and represent state in your
        application with a single Javascript object. Redux uses pure functions called Reducers to enact updates on
        the state object which is represented by the immutable store object. This is straight from their documentation:
            - “Reducers are just pure functions that take the previous state and an action, and return the next state.”
        c. Oftentimes, reducers are written as functions that contain case statements. Take a look at this example
        reducer from their docs:

            import { createStore, combineReducers } from 'redux'
            const SET_NAME = 'SET_NAME'
            const SET_AGE = 'SET_AGE'
            function user(state = initialUserState, action) {
               switch (action.type) {
                   case SET_NAME: {
                       return {
                           ...state,
                           name: action.name,
                       }
                   }
                   case SET_AGE: {
                       return {
                           ...state,
                           age: action.age,
                       }
                   }
               }
            }
            const ADD_TODO = 'ADD_TODO'
            const COMPLETE_TODO = 'COMPLETE_TODO'
            const initialState = {
               todos: []
            }
            function todos(state = initialState, action) {
             switch (action.type) {
               case ADD_TODO: {
                   const { todos } = state
                   return {
                       ...state,
                       todos: [...todos, action.todo],
                   }
               }
               case COMPLETE_TODO: {
                   const { todos } = state
                   const index = todos.find(todo => todo.id == action.id)
                   toods[index].comleted = true
                   return {
                       ...state,
                       todos,
                   }
               }
               default:
                 return state
             }
            }
            const reducers = combineReducers({
               todos,
               user,
            })
            const store = createStore(reducers)

        d. The ellipses before state is called “spreading” the object, which means to return the original value for
        state, except where it is different from the portion of state that was updated, in this case text and completed.
        Redux is a great example of how you can accomplish a lot by making good use of simple concepts.
        e. Functional Highlights of Redux
            - Redux is a big topic and this is not a Redux tutorial. What is important to this course is that Redux has
            found great success among developers because it uses Functional programming practices and is a great example
            of these power concepts being used in the real world.
            - Here are the Functional highlights of the Redux library:
                - A read-only -- or immutable -- state. Reducers don’t update state; they return a brand new object.
                - Pure Function reducers to handle Actions. This means that no actions in our entire app can be affected
                by Side Effects. This is a huge reason Redux is so effective.
                - This careful Functional flow of data from event to store means that the same action, if called twice,
                will have the same effect on the whole application.


        e. reducer ex

            import { DAMAGE_SHIELD, REPAIR_SHIELD } from './actions'

            const initialState = {
                shieldLevel: 100,
            }

            const shieldsReducer = (state = initialState, action) => {
                switch (action.type) {
                    case DAMAGE_SHIELD:
                        const { amount } = action
                        let { shieldLevel } = state

                        shieldLevel -= amount

                        return {
                            ...state,
                            shieldLevel,
                        }

                    case REPAIR_SHIELD:
                        const { amount } = action
                        let { shieldLevel } = state

                        shieldLevel += amount

                        return {
                            ...state,
                            shieldLevel,
                        }
                }
            }

        

