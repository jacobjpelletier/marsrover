A. Functional Programming Intro
    1. Why Do I need FP?
        a. First and probably most importantly, having a solid understanding of another programming paradigm will help
            you write better code - even if you never end up using a functional language or framework in your job.
        b. It is on the rise, more languages are choosing at least functional-inspired styles, and understanding where
           these ideas are coming from will help you learn them faster
        c. It will make learning React less mysterious. React and Redux both heavily ascribe to functional principles.
    2. https://www.youtube.com/watch?v=eis11j_iGMs
        a. y combinator: https://www.youtube.com/watch?v=9T8A89jgeTI
        b. Variable values cannot be edited, but.. functions can return new values.
        c. Programs can be expressed completely with... chains of functions and inputs
        d. Functions... have no effct except the values they return
        e. Dr. Church described programs as assembly lines of functions that... are like black boxes, you cannot
            see the logic inside
B. Programming Paradigms
    1. paradigms
        a. imperative
            - The Imperative Paradigm solves problems with an explicit sequence of commands to get from point A to point
            B. If the code or comments read like a recipe or handbook, it's likely to be imperative. Many programming
            languages, especially dynamic ones, including Javascript, PHP, and Python can be used to write imperative
            programs.
        b. functional:
            - The Functional Paradigm solves problems with functions that hold simple pieces of logic and can
            be chained together to accomplish more complex actions.
        c. OOP
            - The Object-Oriented Paradigm solves problems by defining objects that can hold both values (properties)
            and functionality (methods).
         d. https://cs.lmu.edu/~ray/notes/paradigms/
    2. why learn paradigms?
        a. Javascript is a dynamic language, so you can choose which paradigm to use
        b. how do you choose a paradigm?
            - Here are some things to consider. If your application is inherently state-based, like maybe a simple game,
             blog, or a GUI, it is likely a good candidate for Object Oriented programming, because the entities in an
             Object Oriented program are easier to reason about.
            - On the other hand, if you have a large program that needs to have a high degree of reliability, or if you
            need to manage lots of user interactions and fast updates, then it might be a good sign that you could write
            a Functional program. Functional programs shine especially when you need to leverage concurrency. As chips
            have become about as fast as we can make them, the way to get faster computers has been to add more cores.
            But those cores are useless to make our programs faster unless we can use them well. For a program that
            manages concurrency well, you probably would want to rethink your decision to use JavaScript, but the
            Functional Paradigm would be the best choice.
            - It turns out though, that the choice of programming paradigm is quite personal and subjective among
            developers. Many people will learn a paradigm and more or less stick to it. For instance, a person who is
            comfortable with Object Oriented programs will trend towards creating more Object Oriented programs, because
            at the end of the day, we want to build things more than we want to think about building things.
    3. comparing paradigms
        a. imperative

            let name = 'Captain Kirk'
            let hour = new Date().getHours()

            let greeting = ''

            if (hour <= 6) {
                greeting = 'Good Morning, '
            } else if (hour >= 17) {
                greeting = 'Good Evening, '
            } else {
                greeting = 'Hello, '
            }

            greeting += name + '.'

            console.log(greeting)

        b. functional

            const greet = (name) => (salutation) => `${salutation}, ${name}.`

            const determineSalutation = (callback) => {
                const hour = new Date().getHours()

                if (hour <= 6) {
                    return callback('Good Morning')
                } else if (hour >= 17) {
                    return callback('Good Evening')
                } else {
                    return callback('Hello')
                }
            }

            let result = determineSalutation(greet('Captain Kirk'))
            console.log(result)
            //expected output: Hello, Captain Kirk

        c. oop

            class Person {
                constructor(name){
                    this.name = name
                }

                determineSalutation(date){
                    const hour = (date && date.getHours()) || new Date().getHours()

                    if (hour <= 6) {
                        return "Good Morning"
                    } else if (hour >= 17) {
                        return "Good Evening"
                    } else {
                        return "Hello"
                    }
                }

                greet() {
                    return `${this.determineSalutation()}\u00A0${this.name}`
                    // using JavaScript template literal: `${}`
                    // \u00A0 is a symbol to add a space in the template literal
                }
            }

            const kirk = new Person("Kirk", "Captain")
            console.log(kirk.greet())
            //expected output: Hello, Captain Kirk

            class WarpDrive {
                // Creating a class requires us to decide what properties to give it.
                // Take a look at the imperative program - everything that was a global variable there, we want to make a property on our class
                constructor(type, recipient) {
                    this.type = type
                    this.status = 'active'
                    this.warp = 2
                    this.recipient = recipient ? recipient : 'Captain'
                }

                // The bulk of the logic that the imperative program had in the global scope, we turn into methods
                // The logic will stay mostly the same but we now need to reference values that belong to this instance of class WarpDrive, instead of global variables

                status_report() {
                    if (this.status === 'active' && this.warp <= 4) {
                        return this.recipient + ', the engines are active and we could be going faster'
                    } else if (this.status === 'active' && this.warp > 4) {
                        return this.recipient + ', the engines are active and we are going ' + this.warp
                    } else if (this.status === 'down') {
                        return this.recipient + ', the engines are down'
                    } else {
                        return this.recipient + ', the comms are down and we can`t reach engineering'
                    }
                }

                // Anytime you see a variable changing in the imperative program, it is a sign that a method will be needed in this class
                // I added these setter methods as examples for how you could update the state of the object to test the various status_report responses

                set_status(status) {
                    this.status = status
                }

                set_warp(integer) {
                    this.warp = integer
                }
            }

            // Because we are working with classes now, we have to instantiate the class before we use it

            let enterprise_warp = new WarpDrive('Dilithium Chrystal')

            // NOTE: This is a big win for the object oriented style - it is so easy to make multiple instances of WarpDrive
            // Our program could simultaneously reference as many warp drive as instances as we want -- how would you do that in the imperative program?

            enterprise_warp.set_warp(2)

            console.log(enterprise_warp.status_report())

            // expected output: Captain, the engines are active and we could go faster.

    4. Foundations of FP
        a. pure functions
            - Pure functions are a simple concept with big implications. And to start off with, I’m pretty sure you have
                 already written a pure function! If you started off learning to write functions like this:

                function add(x,y) {
                    return x + y
                }

            - https://mostly-adequate.gitbooks.io/mostly-adequate-guide/ch03.html

        b. Summary on pure functions
            - We just learned about side effects, which modify state and don't come from the return statement of that
            function. So now we have everything we need to understand pure functions. Same inputs get the same output
            and the return value is the total effect of running the function.
            - What do we get from writing pure functions? To sum it up in one word, I would say confidence. But there is
            a lot more to it than that. Here are some last points to consider:

                - If we can count on a function to produce the same result no matter where in the program it runs, then we
                don’t have to be afraid of calling it anywhere. It makes my functions easy to reuse.
                If a function has no side effects, then we remove the mental load of needing to remember them. I have
                - confidence about what my functions do, and the effect they will have on my app. That confidence means
                that I can scale things more easily and alter programs with less fear.

            - immutability
                - Another major tenant of functional programming is that we do not “edit” things; we make new things.
                - For instance, if I had a set of notes for a class, and you wanted to borrow them, when you see
                something that you wanted to edit or add, you wouldn’t make those edits on my notes...hopefully.
                Instead, you would make a fresh copy of my notes and make your changes there. That would preserve my
                copy and let you have your new notes; in essence, that is what functional programming wants.
                - Editing - more commonly referred to in development as “mutating” the same thing over and over again
                makes it hard to know what copy you are looking at, and is prone to errors. At multiple points later in
                the course, we will take a look into how we can create immutable values in our JavaScript programs.
                For now though, this will hopefully explain why we favor ‘const’ variables over ‘let’ variables in this
                course.
            - New Terms
                - Pure Functions - A function that will always return the same output if given the same input, and
                which has no side effects.
                - Side effects - An effect on your overall program from running a function, that did not come from the
                return statement of that function.
                - Immutable - Unchanging. Immutable values are ones which, once declared, cannot be changed.
            - summary
                - The content we learned in this section has an amazing ability to improve your everyday coding skills,
                    even if you aren’t writing a Functional program.
                - You learned that pure functions are completely predictable in their outcome, and as a developer,
                    predictable is exactly what you want your programs to be.
                - Avoiding side effects is partly what makes pure functions predictable, and they also make code easier
                     to read, and reduce the interdependence of programs and functions.
                - We also covered a little bit of how immutable values make it easier to track changes over time, and
                    that it is preferable to make a copy of a value before editing it, rather than making changes to
                    the original.
                - We have now covered the core concepts of Functional Programming. There will be a few more throughout
                    the course, but even using and understanding just these have the power to improve the quality and
                    clarity of your programs.
    5. functional pros and cons
        a. Functional Programming believes that values shouldn’t be sloppily edited, but rather replaced with fresh
        values every time. It also ensures that state changes in very predictable places -- the return values of
        functions. You’ll see that a lot of these pros and cons have to do with how state is handled.
        b. pros
            - Easier to test
              Because every function is pure, we know that the return value is the sum of the function, and is the only
              part that needs to be tested. Functions that avoid side effects are easier to test.

            - More predictable code
              Functions that avoid side effects and the use of immutable values makes changes in the programs more
              visible. By definition, pure functions always return the same value when given the same inputs. This
              predictability is the backbone of success with Functional Programming

            - Easier to edit and expand
              Because pure functions return the same value every time, and perfectly encapsulate their logic in the
              return statement, it means that a function could be copied and pasted to a new part of a program, or
              moved to an entirely different program, and it would still always produce the same result. Functions with
              side effects cannot be moved without the possibility of breaking something.
        c. cons
            - More difficult to write in some languages
              While most modern dynamic languages have the ability to write in a Functional style, it can go against
              the grain with some. Even JavaScript, for instance, does not have a way to make values truly immutable.
              Writing programs without classes goes against the grain of Ruby, and PHP does not have all the array
              methods JavaScript has that follow a Functional methodology.

            - Will never be able to implement completely
              There is a big difference between pure academic Functional programming and practical Functional-inspired
              programming for the web. Unless you are using a language that was built to be Functional, like Haskell,
              there will be times you have to work within the limits of the language to do the best you can at writing
              functional programs.

            - Few libraries to speed progress (though this is changing)
              Functional programming for the web is still fairly new, and there are not as many helpful libraries or
              tutorials for getting started or writing efficiency as there are for say Object Oriented programs, for
              which we have prebuilt ORMs, tons of tutorials, frameworks, etc..
C. Function JS syntax
    1. arrays
        a. map method:

            const captains = ['Picard', 'Adama', 'Reynolds', 'Beeblebrox']

            // create new array
            const titles = captains.map(cap => `Captain ${cap}`)

            // equivalent to
            const titles = captains.map(cap => {
                return `Captain ${cap}`
            })

            console.log('Resulting Array: ', titles)
            // expected output: Resulting Array: ['Captain Picard', 'Captain Adama', 'Captain Reynolds', 'Captain Beeblebrox']
            console.log('Original Array:', captains)
            // is unchanged, expected output: Original Array: ['Picard', 'Adama', 'Reynolds', 'Beeblebrox']


            const nums = [1, 2, 3, 4, 5]

            // Internal callback
            // ----------------------------------------------------------------------
            const doubles = nums.map(x => x * 2)

            console.log(doubles)
            // expected output: Array [2, 4, 6, 8, 10]

            // External callback
            // ----------------------------------------------------------------------
            const doubler = function(x) {
                return x * 2
            }

            const doubles2 = nums.map(x => {
                return doubler
            })

            console.log(doubles2)
            // expected output: Array [2, 4, 6, 8, 10]

            // 1. Write a map function to reverse this array:
            const start = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

            const end = start.map(x => Math.abs(x - 11))
            console.log(end)
            // expected output: Array [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]

            // ----------------------------------------------------------
            // 2. Write a map function to print the Job: Name:
            const shipMates = [["Mal", "Captain"], ["Wash", "Pilot"], ["Zoey", "1st Mate"], ["Jayne", "Public Relations"]]

            const result1 = shipMates.map(arr => arr.reverse().join(': '))
            console.log(result1)

            // expected output: Array ["Captain: Mal", etc...]

            // ----------------------------------------------------------
            // 3. Write a map function that prints the name: even|odd
            const awayTeam = ["Picard", "Riker", "Troy", "Data"]

            const result2 = awayTeam.map((name, i) => `${name}: ${i % 2 === 0 ? 'even' : 'odd'}`)
            console.log(result2)
            // expected output: Array: ["Picard: even", "Riker: odd", etc...]


            // ----------------------------------------------------------
            // 3. Create a multidimensional array of each item and its index in the original Array

            const sciFiShows = ['Manedlorian', 'Enterprise', 'Firefly', 'Battlestar Galactica']

            const result3 = sciFiShows.map((show, index) => [show, index])
            console.log(result3)
            // expected output: Array [['Manedlorian', 0], ['Enterprise', 1], ['Firefly', 2], ['Battlestar Galactica', 3]]

            // ----------------------------------------------------------
            // 4. For each item in this array, create a multidimensional array containing the entire original array

            const numbers = [1, 2, 3, 4]

            const result4 = numbers.map((num, index, wholeArray) => wholeArray)
            console.log(result4)
            // expected output: Array [[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]]


            // ----------------------------------------------------------
            // 5. One common thing we use `map` for in real life is to reformat objects to have a shape that is better for our
            // purposes. For instance, we only care about the name and first three characters of the id for the races below.
            // Use `map` to grab those values and create a new array with them.

            var index = [
                {key: 1, sector: 10, t_score: 18, id: '1236n7e8', value: 'Klingon'},
                {key: 4, sector: 145, t_score: 12, id: '293847hs8', value: 'Minbari'},
                {key: 8, sector: 214, t_score: 5, id: '283hy8347', value: 'Cylon'},
                {key: 3, sector: 8346, t_score: 10, id: 'n9837ks857', value: 'Jawa'},
            ]

            const result5 = index.map((race) => {
                return { name: race.value, idFirstThree: race.id.substring(0,3)}
            })

            console.log(result5);

        b. filter method
            - The filter method is a separator, we give it a function with the logic to distinguish the items we want,
            and filter runs items in the array through that function. In the end, it creates a new array that contains
            only the elements that our function allowed. So the ONLY difference between filter and map is that map
            performs a function on every item in an array, and filter uses a true or false conditional on every item in
            the array to decide if that value should be kept or discarded. This means that one key differentiator of the
            filter method is its callback method must return either true or false. If it returns true, the value will be
            added to the result array; if it returns false, that value is discarded.
            - Filter is easiest to learn when you play around with it. Below, you can see how a filter is applied to the
            values list. This function is looking to see if each value in the array resolves to ‘true’ or not. So the
            ‘filter’ function we are running looks like this: (v == true), where ‘v’ is each value in turn. Only array
            items where this condition is ‘true’ will be included in the new array ‘result’.

                const values = ['true', true, 'yes', 'no', 1, 0, 'false', false];

                const result = values.filter(v => v == true);

                console.log(result);
                // expected output: Array [true, 1]


        c. reduce method
            - The map and filter methods have a lot in common, they both:
                - Run a function (callback given by the developer) on every item in an array.
                - Pass three arguments to the function (item value, item index, whole array).
                - Return a new array.
            - The reduce method has some slight differences. From the name you might be able to guess that this method
            boils our array down to a single value.
            - For example, if you have an array of products, each with a price, you could use reduce to sum the price
            values of each item and return a single total cost. Reduce has the special ability to keep track of a value
            that is updated as it iterates over each item in the array. To get the total cost from an array of items
            with a price value, you would write a function that adds an item's price to the running total and reduce
            will run that function on each item in the array until it runs out of items and the total is found.
            - To do this, reduce only passes the callback two arguments, the total so far - or accumulator, and the
            current item. Another way that it differs from the first two array methods is that it does not necessarily
            return an array. In the case of the example above, reduce would return a single integer of the sum of all
            prices.
            - Below, you can see how reduce is applied to the sales list. Reduce goes through the list sales and adds
            the individual value to a running total which is what will ultimately be returned by reduce. The final
            output of reduce on sales will be 147.49.

                const sales = [120.00, 19.99, 3.50, 4.00];

                const total = sales.reduce((runningTotal, currentValue) => {
                    console.log(runningTotal, currentValue)
                    return runningTotal + currentValue
                })

                // cycle 1: 120 19.99
                // cycle 2: 139.99 3.5
                // cycle 3: 143.49 4

                // expected output: 147.49

                // If you can follow the code above - great job! No one masters the reduce method overnight, but being able to follow the code is the first step. Below are two examples of alternate syntax that you might also see out in the wild. Can you follow these?

                //  SAME AS:
                const reducer = (runningTotal, currentValue) => runningTotal + currentValue;
                console.log(sales.reduce(reducer));

                // Look! You can even run map, filter, and reduce on array literals!
                // SAME AS:
                [120.00, 19.99, 3.50, 4.00].reduce((runningTotal, currentValue) => {
                    return runningTotal + currentValue
                })

        d. summary

        Map - The map method iterates over every item in the array it is called on, and performs one action on each
        item. The action logic is held in a callback function. The map method returns a new array that is the same
        length as the original array, but with the items updated according to the callback function logic.

        Filter - The filter method iterates over every item in the array it is called on, and runs each item through a
        pass or fail checking logic. The logic is held in a callback function which must return either true or false.
        The filter method returns a new array that is shorter than the original array (or potentially the same length,
        if all values passed successfully through the callback), but the values that pass through will be unchanged.

        Reduce - The reduce method iterates over every item in the array it is called on, and keeps one value (for
        instance, the sum of all prices). Each item in the array is forgotten, and the end result is a single value.
        The uses of reduce vary greatly depending on your need, and it is typically the hardest one of the three array
        methods to master because though its logic is not complicated, its use cases can be very creative.

        That concludes our whirlwind tour of the most commonly used array methods! Practicing these will help you in
        your day to day work, and making them second nature will really help in interviews and coding challenges.

    2. Array methods for selection
        a. flat
            - Sometimes we have to deal with arrays within arrays - also called multidimensional arrays. The bigger and
             more nested multidimensional arrays get, the harder they become to wrap your head around, and accessing
             information can be a headache. flat is a tool that allows you to undo array nesting to exactly the level
             you want.
            - In the following code, flat is applied to arrays: nestedArr and moreNested. The first instance with
            nestedArr, flat takes away the higher level of nesting. But with moreNested we can see when flat takes in
            an integer parameter, it will flatten 2 levels of nesting. This returns an array without any nesting.

                var nestedArr = [1, 2, [3, 4, [5, 6]]];
                nestedArr.flat();
                console.log(nestedArr)
                // expected output: [1, 2, 3, 4, [5, 6]]

                var moreNested = [1, 2, [3, 4, [5, 6]]];
                moreNested.flat(2);
                console.log(moreNested)
                // expected output: [1, 2, 3, 4, 5, 6]

        b. find
            - Locating unique values in arrays is another indispensable ability. JavaScript find and Includes methods
            perform similar actions, but their use cases differ. Here are their Mozilla definitions side by side:
                - Find Method
                    - find returns the value of the first element in the provided array that satisfies the provided
                    testing function.
                - Includes Method
                    - includes determines whether an array contains a certain value among its entries, returning true or
                     false as appropriate.
            - find is most useful when you are not looking for a specific value. It is best to use find when you want
            to see if any item in array meets a criteria. In this way, find is a little bit like filter, in that they
            both run every item in array through a function to determine if the item passes the function’s requirement.
            But, find is a little bit simpler in that it only passes a single argument (the current value) and returns
            a single value from the array (the first one to pass the function’s test).

                const bestBars = [
                    'Mos Eisley Cantina',
                    'Clark`s Bar',
                    '10 Forward',
                    'The Restaurant at the End of the Universe',
                    'The Prancing Pony',
                    '10 Forward',
                ]

                const test1 = bestBars.find(x => x === 'Quark`s Bar')
                const test2 = bestBars.find(x => x === '10 Forward')

                console.log(test1) //expected output: undefined
                console.log(test2) // expected output: 10 Forward
        c. include
            - includes is most useful when are looking for the existence of a specific value. All you have to do is
            provide the value you are looking for, and includes will return true if it finds it and false if it does not.
            - It is good to note that neither find nor includes is a good tool to use if you need to know how many
            times a value is found in an array. To do that, you would have to use map or filter.
            - In the following code, you can see that includes only returns a true or false value. Includes can also be
            used on strings.

                const bestBars = [
                    'Mos Eisley Cantina',
                    'Clark`s Bar',
                    '10 Forward',
                    'The Restaurant at the End of the Universe',
                    'The Prancing Pony',
                    '10 Forward',
                ]

                const test1 = bestBars.includes('Quark`s Bar')
                const test2 = bestBars.includes('The Prancing Pony')

                console.log(test1) // expected output: false
                console.log(test2) // expected output: true

    3.  variables
        a. let
            - let is like var in that a value can be edited after it has been declared, but the scoping rules are a bit
            different between the two.
        b. const
            - const is what we are going to focus on in this course, and right now, we are just going to look at how
            const does not go far enough to really be considered functional. In the following example, take a close
            look at how the consts ‘currentBook’ and ‘bookDetails’ behave differently. We can’t edit ‘currentBook’ -
            as expected - but we CAN edit ‘bookDetails’. Feel free to run and edit the code below to get a feel for
            what you can and can’t do.

                const currentBook = 'The Time Machine'

                const bookDetails = {
                   title: 'The Time Machine',
                   author: 'H. G. Wells',
                   totalPages: 84,
                   currentPage: 42
                }

                const library = ['Dune', 'Nineteen Eighty-Four', 'Ender`s Game', 'Hyperion', 'Fahrenheit 451']

                currentBook = 'Stranger in a Strange Land'
                // results in error, can't edit const value

                bookDetails = {
                   title: 'I, Robot',
                   author: 'Isaac Asimov',
                   totalPages: 253,
                   currentPage: 21
                }
                // results in error, bookDetails is read-only

                bookDetails.currentPage = 75
                // this works! We can update values within a const object

                library = ['Dune', 'Nineteen Eighty-Four']
                // results in error, can't redeclare library

                library.concat('The Hitchiker`s Guide to the Galaxy')
                // this works! We can update items in the array or add to it
                // Note that concat is the best non-mutative way to add items to an array

            https://hackernoon.com/why-you-shouldnt-use-var-anymore-f109a58b9b70
            https://dev.to/johnwolfe820/should-you-never-truly-use-var-bdi

        c. object freeze

            // ----------------------------------------------------------
            // OBJECT FREEZE EXAMPLES
            // ----------------------------------------------------------

            const currentShow = {
                title: 'Dr. Who',
                seasons: 11,
                currentSeason: 4
            }

            // as a const, we can do this:
            currentShow.currentSeason = 5
            // expected output: { title: 'Dr. Who', seasons: 11, currentSeasons: 5 }

            // but if we freeze the object
            Object.freeze(currentShow);

            currentShow.currentSeason = 6;
            // this would actually cause an error

            console.log(currentShow)
            // expected output: {title: 'Dr. Who', seasons: 11, currentSeasons: 5 }
            // now that it is frozen we can not update the current season of the current show

        - freeze
            - A frozen object can no longer be changed.” A frozen object can have no properties added to it, removed
             from it, or its values edited. It effectively makes an immutable object.
    4. keys()
        - This method returns an array of strings of all an object’s property names. This is unusual because most
          methods we run on objects are more interested in the values.
        - Be aware though, this won’t always get the results you think. Along with the properties you are aware of in
          an object, this might also return other properties belonging to the prototype.
    5. assign()

        let state = {
            name: 'Wash',
            ship: {
                name: 'Serenity',
                class: 'Firefly'
            }
            role: 'Pilot',
            favoriteThing: {
                item: "Toy",
                details: {
                        type: 'Toy Tyrannosaurus Rex'
                }
            }
        }

        const newState = {
            name: 'Mal',
            role: 'Captain',
            favoriteThing: {
                item: "Not complicated"
            },
            history: ["Browncoat sergeant"]
        }

        state = Object.assign(state, newState);
        // Object.assign(state, newState)

        console.log(state)
        // expected output:
        // { name: 'Mal',  ship: { name: 'Serenity', class: 'Firefly' },
        //  role: 'Captain',
        //  favoriteThing: { item: 'Not complicated' },
        //  history: [ 'Browncoat sergeant' ] }

    6. method examples

        // ----------------------------------------------------------
        // OBJECT FREEZE EXERCISE
        // Create your own object and freeze it!
        // Below is an example of a solution to the exercise.
        // --------------------------------------------------------

        // much like the example you saw in the video create an object

        const person = {
            name: 'Synthia',
            age: 12
        }
        console.log(person)
        // expected output: {name: 'Synthia', age: 12}

        person.age = 13
        console.log(person)
        // expected output: {name: 'Synthia', age: 13}

        Object.freeze(person)

        person.age = 14
        console.log(person)
        // expected output: {name: 'Synthia', age: 13}

        // ----------------------------------------------------------
        // OBJECT KEYS EXERCISES
        // Use Object.keys with the map method to print "This character has a(n) [property-name]" for each property.
        // ----------------------------------------------------------
        // GIVEN
        const character = {
            id: '12mn18udcbv9823',
            name: 'Chewbacca',
            race: 'Wookie',
            planet: 'Kashyyyk',
            job: 'First Mate'
        }

        // SOLUTION CODE
        const keys = Object.keys(character)

        keys.map(key => {
            console.log(This character has a(n) ${key})
            return This character has a(n) ${key}
        })

        // Expected Output:
        // This character has a(n) id.
        // This character has a(n) name.
        // This character has a(n) race.
        // This character has a(n) planet.
        // This character has a(n) job.
        // [ 'This character has a(n) id',  'This character has a(n) name',  'This character has a(n) race', 'This character has a(n) planet', 'This character has a(n) job' ]

        // ----------------------------------------------------------
        // OBJECT ASSIGN EXERCISES
        // Merge another character into this state. Keep at least one value and change at least one value. Below is an example of a solution to the exercise.
        // ----------------------------------------------------------

        let state = {
            name: 'Wash',
            ship: {
                name: 'Serenity',
                class: 'Firefly'
            },
            role: 'Pilot',
            favoriteThing: {
                item: "Toy",
                details: {
                    type: 'Toy Tyrannosaurus Rex'
                }
            }
        }

        const incomingState = {
            name: 'Mal',
            role: 'Captain',
            favoriteThing: {
                item: "Not complicated"
            },
            history: ["Browncoat sergeant"]
        }

        state = Object.assign(state, incomingState);
        // expected output:
        // state = {
        //     name: "Mal",
        //     ship: {
        //         name: "Serenity",
        //         class: "Firefly"
        //     },
        //     role: "Captain",
        //     favoriteThing: {
        //         item: "Not complicated"
        //     },
        //     history: ["Browncoat sergeant"]
        // }












